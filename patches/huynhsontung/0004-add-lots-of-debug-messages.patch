From 961ac8c54340f6f91d429cbb7f5d0438539964d6 Mon Sep 17 00:00:00 2001
From: Tung Huynh <tung75605@gmail.com>
Date: Wed, 7 May 2025 03:38:36 -0700
Subject: [PATCH 4/4] add lots of debug messages

---
 modules/video_output/win32/common.c         |  15 ++-
 modules/video_output/win32/d3d11_scaler.cpp |  23 ++++-
 modules/video_output/win32/d3d11_shaders.c  |  29 +++++-
 modules/video_output/win32/direct3d11.c     | 108 +++++++++++++++++++-
 4 files changed, 164 insertions(+), 11 deletions(-)

diff --git a/modules/video_output/win32/common.c b/modules/video_output/win32/common.c
index 83812826cc..4f7c6b7e66 100644
--- a/modules/video_output/win32/common.c
+++ b/modules/video_output/win32/common.c
@@ -79,6 +79,7 @@ static unsigned int GetPictureHeight(const vout_display_t *vd)
 /* */
 int CommonInit(vout_display_t *vd)
 {
+    msg_Dbg(vd, "[direct3d11] Enter: CommonInit");
     vout_display_sys_t *sys = vd->sys;
 
     sys->hwnd      = NULL;
@@ -141,14 +142,18 @@ int CommonInit(vout_display_t *vd)
     sys->dxgidebug_dll = LoadLibrary(TEXT("DXGIDEBUG.DLL"));
 #endif
 
+    msg_Dbg(vd, "[direct3d11] Exit: CommonInit");
     return VLC_SUCCESS;
 }
 
 /* */
 picture_pool_t *CommonPool(vout_display_t *vd, unsigned count)
 {
+    msg_Dbg(vd, "[direct3d11] Enter: CommonPool");
     VLC_UNUSED(count);
-    return vd->sys->pool;
+    picture_pool_t *pool = vd->sys->pool;
+    msg_Dbg(vd, "[direct3d11] Exit: CommonPool");
+    return pool;
 }
 
 /*****************************************************************************
@@ -162,6 +167,7 @@ void UpdateRects(vout_display_t *vd,
     const vout_display_cfg_t *cfg,
     bool is_forced)
 {
+    msg_Dbg(vd, "[direct3d11] Enter: UpdateRects");
     vout_display_sys_t *sys = vd->sys;
     const video_format_t *source = sys->src_fmt;
 #define rect_src sys->rect_src
@@ -374,6 +380,7 @@ exit:
 #undef rect_src_clipped
 #undef rect_dest
 #undef rect_dest_clipped
+    msg_Dbg(vd, "[direct3d11] Exit: UpdateRects");
 }
 
 #if !VLC_WINSTORE_APP
@@ -654,6 +661,7 @@ void CommonChangeThumbnailClip(vout_display_t *vd, bool show) {}
 
 int CommonControl(vout_display_t *vd, int query, va_list args)
 {
+    msg_Dbg(vd, "[direct3d11] Enter: CommonControl");
     vout_display_sys_t *sys = vd->sys;
 
     switch (query) {
@@ -670,6 +678,7 @@ int CommonControl(vout_display_t *vd, int query, va_list args)
             cfg    = va_arg(args, const vout_display_cfg_t *);
         }
         UpdateRects(vd, cfg, true);
+        msg_Dbg(vd, "[direct3d11] Exit: CommonControl");
         return VLC_SUCCESS;
     }
 #if !VLC_WINSTORE_APP
@@ -692,6 +701,7 @@ int CommonControl(vout_display_t *vd, int query, va_list args)
                          rect_window.bottom - rect_window.top, SWP_NOMOVE);
         }
         UpdateRects(vd, cfg, false);
+        msg_Dbg(vd, "[direct3d11] Exit: CommonControl");
         return VLC_SUCCESS;
     }
     case VOUT_DISPLAY_CHANGE_WINDOW_STATE: {       /* unsigned state */
@@ -713,6 +723,7 @@ int CommonControl(vout_display_t *vd, int query, va_list args)
             SetWindowPos(sys->hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE);
         }
         sys->is_on_top = is_on_top;
+        msg_Dbg(vd, "[direct3d11] Exit: CommonControl");
         return VLC_SUCCESS;
     }
     case VOUT_DISPLAY_CHANGE_FULLSCREEN: {
@@ -722,6 +733,7 @@ int CommonControl(vout_display_t *vd, int query, va_list args)
         if (CommonControlSetFullscreen(vd, fs))
             return VLC_EGENERIC;
         UpdateRects(vd, NULL, false);
+        msg_Dbg(vd, "[direct3d11] Exit: CommonControl");
         return VLC_SUCCESS;
     }
 
@@ -729,6 +741,7 @@ int CommonControl(vout_display_t *vd, int query, va_list args)
         vlc_assert_unreachable();
 #endif
     default:
+        msg_Dbg(vd, "[direct3d11] Exit: CommonControl");
         return VLC_EGENERIC;
     }
 }
diff --git a/modules/video_output/win32/d3d11_scaler.cpp b/modules/video_output/win32/d3d11_scaler.cpp
index d0b3227a78..6e78ac2247 100644
--- a/modules/video_output/win32/d3d11_scaler.cpp
+++ b/modules/video_output/win32/d3d11_scaler.cpp
@@ -60,9 +60,11 @@ static const d3d_format_t *GetDirectRenderingFormat(vlc_object_t *vd, d3d11_devi
 d3d11_scaler *D3D11_UpscalerCreate(vlc_object_t *vd, d3d11_device_t *d3d_dev, vlc_fourcc_t i_chroma,
                                    bool super_res, const d3d_format_t **out_fmt)
 {
+    msg_Dbg(vd, "Enter D3D11_UpscalerCreate");
     if ((*out_fmt)->formatTexture == DXGI_FORMAT_UNKNOWN)
     {
         msg_Warn(vd, "chroma upscale of %4.4s not supported", (char*)&i_chroma);
+        msg_Dbg(vd, "Exit D3D11_UpscalerCreate");
         return nullptr;
     }
 
@@ -213,6 +215,7 @@ checked:
     scaleProc->d3d_fmt = fmt;
     scaleProc->super_res = super_res;
     *out_fmt = scaleProc->d3d_fmt;
+    msg_Dbg(vd, "Exit D3D11_UpscalerCreate");
     return scaleProc;
 error:
 #ifdef HAVE_AMF_SCALER
@@ -222,6 +225,7 @@ error:
         vlc_AMFReleaseContext(&amf);
 #endif
     delete scaleProc;
+    msg_Dbg(vd, "Exit D3D11_UpscalerCreate");
     return nullptr;
 }
 
@@ -246,6 +250,7 @@ int D3D11_UpscalerUpdate(vlc_object_t *vd, d3d11_scaler *scaleProc, d3d11_device
                          const video_format_t *fmt, video_format_t *quad_fmt,
                          const vout_display_cfg_t *cfg)
 {
+    msg_Dbg(vd, "Enter D3D11_UpscalerUpdate");
     HRESULT hr;
     ID3D11Texture2D *_upscaled[D3D11_MAX_SHADER_VIEW];
     ComPtr<ID3D11Texture2D> upscaled;
@@ -273,8 +278,10 @@ int D3D11_UpscalerUpdate(vlc_object_t *vd, d3d11_scaler *scaleProc, d3d11_device
 
     if (scaleProc->Width == out_width && scaleProc->Height == out_height &&
         memcmp(&scaleProc->place, &place, sizeof(place)) == 0)
-        // do nothing
+    {
+        msg_Dbg(vd, "Exit D3D11_UpscalerUpdate");
         return VLC_SUCCESS;
+    }
     scaleProc->place = place;
 
     scaleProc->usable = false;
@@ -590,11 +597,13 @@ int D3D11_UpscalerUpdate(vlc_object_t *vd, d3d11_scaler *scaleProc, d3d11_device
     }
 
     scaleProc->usable = true;
+    msg_Dbg(vd, "Exit D3D11_UpscalerUpdate");
     return VLC_SUCCESS;
 done_super:
     ReleaseSRVs(scaleProc);
     scaleProc->processor.Reset();
     scaleProc->enumerator.Reset();
+    msg_Dbg(vd, "Exit D3D11_UpscalerUpdate");
     return VLC_EGENERIC;
 }
 
@@ -621,6 +630,7 @@ void D3D11_UpscalerDestroy(d3d11_scaler *scaleProc)
 
 static int assert_ProcessorInput(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t *p_sys_src)
 {
+    msg_Dbg(vd, "Enter assert_ProcessorInput");
     if (!p_sys_src->processorInput)
     {
         D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC inDesc{};
@@ -641,14 +651,17 @@ static int assert_ProcessorInput(vlc_object_t *vd, d3d11_scaler *scaleProc, pict
 #ifndef NDEBUG
             msg_Dbg(vd,"Failed to create processor input for slice %d. (hr=0x%lX)", p_sys_src->slice_index, hr);
 #endif
+            msg_Dbg(vd, "Exit assert_ProcessorInput");
             return VLC_EGENERIC;
         }
     }
+    msg_Dbg(vd, "Exit assert_ProcessorInput");
     return VLC_SUCCESS;
 }
 
 int D3D11_UpscalerScale(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t *p_sys)
 {
+    msg_Dbg(vd, "Enter D3D11_UpscalerScale");
     HRESULT hr;
 
 #ifdef HAVE_AMF_SCALER
@@ -687,11 +700,13 @@ int D3D11_UpscalerScale(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t
         if (res == AMF_INPUT_FULL)
         {
             msg_Dbg(vd, "scaler input full, skip this frame");
+            msg_Dbg(vd, "Exit D3D11_UpscalerScale");
             return VLC_SUCCESS;
         }
         if (res != AMF_OK)
         {
             msg_Err(vd, "scaler input failed, (err=%d)", res);
+            msg_Dbg(vd, "Exit D3D11_UpscalerScale");
             return VLC_EGENERIC;
         }
 
@@ -700,6 +715,7 @@ int D3D11_UpscalerScale(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t
         if (res != AMF_OK)
         {
             msg_Err(vd, "scaler gave no output full, (err=%d)", res);
+            msg_Dbg(vd, "Exit D3D11_UpscalerScale");
             return VLC_EGENERIC;
         }
 
@@ -726,6 +742,7 @@ int D3D11_UpscalerScale(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t
         if (D3D11_AllocateShaderView(vd, scaleProc->d3d_dev->d3ddevice, scaleProc->d3d_fmt,
                                     _upscaled, 0, scaleProc->SRVs) != VLC_SUCCESS)
         {
+            msg_Dbg(vd, "Exit D3D11_UpscalerScale");
             return (-ENOTSUP);
         }
 
@@ -744,12 +761,14 @@ int D3D11_UpscalerScale(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t
 
         amfOutput->Release();
 
+        msg_Dbg(vd, "Exit D3D11_UpscalerScale");
         return VLC_SUCCESS;
     }
 #endif
     if (assert_ProcessorInput(vd, scaleProc, p_sys) != VLC_SUCCESS)
     {
         msg_Err(vd, "fail to create upscaler input");
+        msg_Dbg(vd, "Exit D3D11_UpscalerScale");
         return VLC_EGENERIC;
     }
 
@@ -763,8 +782,10 @@ int D3D11_UpscalerScale(vlc_object_t *vd, d3d11_scaler *scaleProc, picture_sys_t
     if (FAILED(hr))
     {
         msg_Err(vd, "Failed to render the upscaled texture. (hr=0x%lX)", hr);
+        msg_Dbg(vd, "Exit D3D11_UpscalerScale");
         return VLC_EGENERIC;
     }
+    msg_Dbg(vd, "Exit D3D11_UpscalerScale");
     return VLC_SUCCESS;
 }
 
diff --git a/modules/video_output/win32/d3d11_shaders.c b/modules/video_output/win32/d3d11_shaders.c
index 72ed6a83b5..a17ef8a1ca 100644
--- a/modules/video_output/win32/d3d11_shaders.c
+++ b/modules/video_output/win32/d3d11_shaders.c
@@ -209,6 +209,8 @@ HRESULT D3D11_CompilePixelShader(vlc_object_t *o, d3d11_handle_t *hd3d, bool leg
                                  video_color_primaries_t primaries, bool src_full_range,
                                  ID3D11PixelShader **output)
 {
+    msg_Dbg(o, "Enter D3D11_CompilePixelShader");
+
     static const char *DEFAULT_NOOP = "return rgb";
     const char *psz_sampler;
     const char *psz_src_transform     = DEFAULT_NOOP;
@@ -455,6 +457,7 @@ HRESULT D3D11_CompilePixelShader(vlc_object_t *o, d3d11_handle_t *hd3d, bool leg
     {
         msg_Err(o, "no room for the Pixel Shader");
         free(psz_range);
+        msg_Dbg(o, "Exit D3D11_CompilePixelShader");
         return E_OUTOFMEMORY;
     }
     sprintf(shader, globPixelShaderDefault, legacy_shader ? "" : "Array", psz_src_transform,
@@ -476,13 +479,17 @@ HRESULT D3D11_CompilePixelShader(vlc_object_t *o, d3d11_handle_t *hd3d, bool leg
     ID3DBlob *pPSBlob = D3D11_CompileShader(o, hd3d, d3d_dev, shader, true);
     free(shader);
     if (!pPSBlob)
+    {
+        msg_Dbg(o, "Exit D3D11_CompilePixelShader");
         return E_INVALIDARG;
+    }
 
     HRESULT hr = ID3D11Device_CreatePixelShader(d3d_dev->d3ddevice,
                                                 (void *)ID3D10Blob_GetBufferPointer(pPSBlob),
                                                 ID3D10Blob_GetBufferSize(pPSBlob), NULL, output);
 
     ID3D10Blob_Release(pPSBlob);
+    msg_Dbg(o, "Exit D3D11_CompilePixelShader");
     return hr;
 }
 
@@ -490,6 +497,8 @@ HRESULT D3D11_CompilePixelShader(vlc_object_t *o, d3d11_handle_t *hd3d, bool leg
 ID3DBlob* D3D11_CompileShader(vlc_object_t *obj, const d3d11_handle_t *hd3d, const d3d11_device_t *d3d_dev,
                               const char *psz_shader, bool pixel)
 {
+    msg_Dbg(obj, "Enter D3D11_CompileShader");
+
     ID3DBlob* pShaderBlob = NULL, *pErrBlob;
     const char *target;
     if (pixel)
@@ -520,30 +529,42 @@ ID3DBlob* D3D11_CompileShader(vlc_object_t *obj, const d3d11_handle_t *hd3d, con
         msg_Err(obj, "invalid %s Shader (hr=0x%lX): %s", pixel?"Pixel":"Vertex", hr, err );
         if (pErrBlob)
             ID3D10Blob_Release(pErrBlob);
+        msg_Dbg(obj, "Exit D3D11_CompileShader");
         return NULL;
     }
+    msg_Dbg(obj, "Exit D3D11_CompileShader");
     return pShaderBlob;
 }
 
 #undef GetFormatLuminance
 float GetFormatLuminance(vlc_object_t *o, const video_format_t *fmt)
 {
+    msg_Dbg(o, "Enter GetFormatLuminance");
+
+    float luminance;
     switch (fmt->transfer)
     {
         case TRANSFER_FUNC_SMPTE_ST2084:
             /* that's the default PQ value if the metadata are not set */
-            return MAX_PQ_BRIGHTNESS;
+            luminance = MAX_PQ_BRIGHTNESS;
+            break;
         case TRANSFER_FUNC_HLG:
-            return MAX_HLG_BRIGHTNESS;
+            luminance = MAX_HLG_BRIGHTNESS;
+            break;
         case TRANSFER_FUNC_BT470_BG:
         case TRANSFER_FUNC_BT470_M:
         case TRANSFER_FUNC_BT709:
         case TRANSFER_FUNC_SRGB:
-            return DEFAULT_BRIGHTNESS;
+            luminance = DEFAULT_BRIGHTNESS;
+            break;
         default:
             msg_Dbg(o, "unhandled source transfer %d", fmt->transfer);
-            return DEFAULT_BRIGHTNESS;
+            luminance = DEFAULT_BRIGHTNESS;
+            break;
     }
+
+    msg_Dbg(o, "Exit GetFormatLuminance");
+    return luminance;
 }
 
 HRESULT D3D11_CreateRenderTargets( d3d11_device_t *d3d_dev, ID3D11Resource *texture,
diff --git a/modules/video_output/win32/direct3d11.c b/modules/video_output/win32/direct3d11.c
index 426d273cf2..0ab91b8ead 100644
--- a/modules/video_output/win32/direct3d11.c
+++ b/modules/video_output/win32/direct3d11.c
@@ -265,6 +265,9 @@ static bool GetWinRTSize(const vout_display_sys_win32_t *p_sys, UINT *w, UINT *h
 
 static int OpenCoreW(vout_display_t *vd)
 {
+    vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter OpenCoreW");
+
     IDXGISwapChain1* dxgiswapChain  = (void*)var_InheritInteger(vd, "winrt-swapchain");
     if (!dxgiswapChain)
         return VLC_EGENERIC;
@@ -276,7 +279,6 @@ static int OpenCoreW(vout_display_t *vd)
     if (!d3ddevice)
         return VLC_EGENERIC;
 
-    vout_display_sys_t *sys = vd->sys;
     sys->dxgiswapChain = dxgiswapChain;
     sys->d3d_dev.d3ddevice     = d3ddevice;
     sys->d3d_dev.d3dcontext    = d3dcontext;
@@ -286,6 +288,7 @@ static int OpenCoreW(vout_display_t *vd)
 
     sys->sys.pf_GetWindowSize = GetWinRTSize;
 
+    msg_Dbg(vd, "Exit OpenCoreW");
     return VLC_SUCCESS;
 }
 
@@ -588,7 +591,7 @@ static void FillSwapChainDesc(vout_display_t *vd, DXGI_SWAP_CHAIN_DESC1 *out)
 static int UpdateSamplers(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
-    HRESULT hr;
+    msg_Dbg(vd, "Enter UpdateSamplers");
 
     D3D11_SAMPLER_DESC sampDesc;
     memset(&sampDesc, 0, sizeof(sampDesc));
@@ -606,10 +609,11 @@ static int UpdateSamplers(vout_display_t *vd)
         sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
     else
         sampDesc.Filter = D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
-    hr = ID3D11Device_CreateSamplerState(sys->d3d_dev.d3ddevice, &sampDesc, &d3dsampState[0]);
+    HRESULT hr = ID3D11Device_CreateSamplerState(sys->d3d_dev.d3ddevice, &sampDesc, &d3dsampState[0]);
     if (FAILED(hr)) {
         msg_Err(vd, "Could not Create the D3d11 Sampler State. (hr=0x%lX)", hr);
         d3d11_device_unlock(&sys->d3d_dev);
+        msg_Dbg(vd, "Exit UpdateSamplers with error");
         return VLC_EGENERIC;
     }
 
@@ -619,6 +623,7 @@ static int UpdateSamplers(vout_display_t *vd)
         msg_Err(vd, "Could not Create the D3d11 Sampler State. (hr=0x%lX)", hr);
         ID3D11SamplerState_Release(d3dsampState[0]);
         d3d11_device_unlock(&sys->d3d_dev);
+        msg_Dbg(vd, "Exit UpdateSamplers with error");
         return VLC_EGENERIC;
     }
 
@@ -627,6 +632,7 @@ static int UpdateSamplers(vout_display_t *vd)
     ID3D11SamplerState_Release(d3dsampState[1]);
 
     d3d11_device_unlock(&sys->d3d_dev);
+    msg_Dbg(vd, "Exit UpdateSamplers");
     return VLC_SUCCESS;
 }
 
@@ -634,6 +640,7 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
     HRESULT hr;
+    msg_Dbg(vd, "Enter UpdateBackBuffer");
     ID3D11Texture2D* pDepthStencil;
     ID3D11Texture2D* pBackBuffer;
     UINT window_width, window_height;
@@ -671,7 +678,10 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
     }
 
     if (dsc.Width == window_width && dsc.Height == window_height)
+    {
+        msg_Dbg(vd, "Exit UpdateBackBuffer succeeded");
         return S_OK; /* nothing changed */
+    }
 
     if (sys->d3drenderTargetView) {
         ID3D11RenderTargetView_Release(sys->d3drenderTargetView);
@@ -687,12 +697,14 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
         DXGI_FORMAT_UNKNOWN, 0);
     if (FAILED(hr)) {
        msg_Err(vd, "Failed to resize the backbuffer. (hr=0x%lX)", hr);
+       msg_Dbg(vd, "Exit UpdateBackBuffer failed");
        return hr;
     }
 
     hr = IDXGISwapChain_GetBuffer(sys->dxgiswapChain, 0, &IID_ID3D11Texture2D, (LPVOID *)&pBackBuffer);
     if (FAILED(hr)) {
        msg_Err(vd, "Could not get the backbuffer for the Swapchain. (hr=0x%lX)", hr);
+       msg_Dbg(vd, "Exit UpdateBackBuffer failed");
        return hr;
     }
 
@@ -700,6 +712,7 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
     ID3D11Texture2D_Release(pBackBuffer);
     if (FAILED(hr)) {
         msg_Err(vd, "Failed to create the target view. (hr=0x%lX)", hr);
+        msg_Dbg(vd, "Exit UpdateBackBuffer failed");
         return hr;
     }
 
@@ -720,6 +733,7 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
     hr = ID3D11Device_CreateTexture2D(sys->d3d_dev.d3ddevice, &deptTexDesc, NULL, &pDepthStencil);
     if (FAILED(hr)) {
        msg_Err(vd, "Could not create the depth stencil texture. (hr=0x%lX)", hr);
+       msg_Dbg(vd, "Exit UpdateBackBuffer failed");
        return hr;
     }
 
@@ -735,9 +749,11 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
 
     if (FAILED(hr)) {
        msg_Err(vd, "Could not create the depth stencil view. (hr=0x%lX)", hr);
+       msg_Dbg(vd, "Exit UpdateBackBuffer failed");
        return hr;
     }
 
+    msg_Dbg(vd, "Exit UpdateBackBuffer succeeded");
     return S_OK;
 }
 
@@ -858,14 +874,22 @@ static float UpdateZ(float f_fovx, float f_fovy)
 
 static void SetQuadVSProjection(vout_display_t *vd, d3d_quad_t *quad, const vlc_viewpoint_t *p_vp)
 {
+    vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter SetQuadVSProjection");
     if (!quad->pVertexShaderConstants)
+    {
+        msg_Dbg(vd, "Exit SetQuadVSProjection (no vertex shader constants)");
         return;
+    }
 
 #define RAD(d) ((float) ((d) * M_PI / 180.f))
     float f_fovx = RAD(p_vp->fov);
     if ( f_fovx > FIELD_OF_VIEW_DEGREES_MAX * M_PI / 180 + 0.001f ||
          f_fovx < -0.001f )
+    {
+        msg_Dbg(vd, "Exit SetQuadVSProjection (invalid FOV)");
         return;
+    }
 
     float f_sar = (float) vd->cfg->display.width / vd->cfg->display.height;
     float f_teta = RAD(p_vp->yaw) - (float) M_PI_2;
@@ -874,7 +898,6 @@ static void SetQuadVSProjection(vout_display_t *vd, d3d_quad_t *quad, const vlc_
     float f_fovy = UpdateFOVy(f_fovx, f_sar);
     float f_z = UpdateZ(f_fovx, f_fovy);
 
-    vout_display_sys_t *sys = vd->sys;
     HRESULT hr;
     D3D11_MAPPED_SUBRESOURCE mapped;
     hr = ID3D11DeviceContext_Map(sys->d3d_dev.d3dcontext, (ID3D11Resource *)quad->pVertexShaderConstants, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped);
@@ -888,11 +911,14 @@ static void SetQuadVSProjection(vout_display_t *vd, d3d_quad_t *quad, const vlc_
     }
     ID3D11DeviceContext_Unmap(sys->d3d_dev.d3dcontext, (ID3D11Resource *)quad->pVertexShaderConstants, 0);
 #undef RAD
+    msg_Dbg(vd, "Exit SetQuadVSProjection");
 }
 
 static void UpdateSize(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter UpdateSize");
+
     msg_Dbg(vd, "Detected size change %dx%d", RECTWidth(sys->sys.rect_dest_clipped),
             RECTHeight(sys->sys.rect_dest_clipped));
 
@@ -906,6 +932,7 @@ static void UpdateSize(vout_display_t *vd)
                              vd->fmt.orientation);
 
     d3d11_device_unlock( &sys->d3d_dev );
+    msg_Dbg(vd, "Exit UpdateSize");
 }
 
 static inline bool RectEquals(const RECT *r1, const RECT *r2)
@@ -917,6 +944,7 @@ static inline bool RectEquals(const RECT *r1, const RECT *r2)
 static int Control(vout_display_t *vd, int query, va_list args)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Control with query %d", query);
     RECT before_src_clipped  = sys->sys.rect_src_clipped;
     RECT before_dest_clipped = sys->sys.rect_dest_clipped;
     RECT before_dest         = sys->sys.rect_dest;
@@ -967,12 +995,14 @@ static int Control(vout_display_t *vd, int query, va_list args)
         UpdateSize(vd);
     }
 
+    msg_Dbg(vd, "Exit Control");
     return res;
 }
 
 static void Manage(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Manage");
     RECT before_src_clipped  = sys->sys.rect_src_clipped;
     RECT before_dest_clipped = sys->sys.rect_dest_clipped;
     RECT before_dest         = sys->sys.rect_dest;
@@ -985,11 +1015,13 @@ static void Manage(vout_display_t *vd)
     {
         UpdateSize(vd);
     }
+    msg_Dbg(vd, "Exit Manage");
 }
 
 static void CallUpdateRects(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter CallUpdateRects");
     if (sys->scaleProc && D3D11_UpscalerUsed(sys->scaleProc))
     {
         D3D11_UpscalerGetSize(sys->scaleProc, &sys->quad_fmt.i_width, &sys->quad_fmt.i_height);
@@ -1009,11 +1041,13 @@ static void CallUpdateRects(vout_display_t *vd)
     {
         UpdateRects(vd, NULL, true);
     }
+    msg_Dbg(vd, "Exit CallUpdateRects");
 }
 
 static int CreateStaging(vout_display_t *vd, ID3D11DeviceContext *shared_context)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter CreateStaging");
     ID3D11Texture2D *textures[D3D11_MAX_SHADER_VIEW] = {0};
     video_format_t surface_fmt = sys->pool_fmt;
     surface_fmt.i_width  = sys->picQuad.i_width;
@@ -1023,6 +1057,7 @@ static int CreateStaging(vout_display_t *vd, ID3D11DeviceContext *shared_context
                          false, shared_context != NULL, 1, textures))
     {
         msg_Err(vd, "Failed to allocate the staging texture");
+        msg_Dbg(vd, "Exit CreateStaging with error");
         return VLC_EGENERIC;
     }
 
@@ -1031,6 +1066,7 @@ static int CreateStaging(vout_display_t *vd, ID3D11DeviceContext *shared_context
                                  textures, 0, sys->stagingSys.resourceView))
     {
         msg_Err(vd, "Failed to allocate the staging shader view");
+        msg_Dbg(vd, "Exit CreateStaging with error");
         return VLC_EGENERIC;
     }
 
@@ -1049,16 +1085,19 @@ static int CreateStaging(vout_display_t *vd, ID3D11DeviceContext *shared_context
         if (FAILED(hr))
         {
             msg_Err(vd, "Failed to get the shared handle");
+            msg_Dbg(vd, "Exit CreateStaging with error");
             return VLC_EGENERIC;
         }
     }
 
+    msg_Dbg(vd, "Exit CreateStaging");
     return VLC_SUCCESS;
 }
 
 static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Prepare");
 
     if (sys->picQuad.formatInfo->formatTexture == DXGI_FORMAT_UNKNOWN)
     {
@@ -1107,13 +1146,19 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
         if (sys->scaleProc && D3D11_UpscalerUsed(sys->scaleProc))
         {
             if (D3D11_UpscalerScale(VLC_OBJECT(vd), sys->scaleProc, p_sys) != VLC_SUCCESS)
+            {
+                msg_Dbg(vd, "Exit Prepare with error");
                 return;
+            }
             p_sys = D3D11_UpscalerGetOutput(sys->scaleProc);
         }
         if (sys->tonemapProc)
         {
             if (FAILED(D3D11_TonemapperProcess(VLC_OBJECT(vd), sys->tonemapProc, p_sys)))
+            {
+                msg_Dbg(vd, "Exit Prepare with error");
                 return;
+            }
             p_sys = D3D11_TonemapperGetOutput(sys->tonemapProc);
         }
 
@@ -1133,6 +1178,7 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
                 {
                     if (is_d3d11_opaque(picture->format.i_chroma))
                         d3d11_device_unlock( &sys->d3d_dev );
+                    msg_Dbg(vd, "Exit Prepare with error");
                     return;
                 }
             }
@@ -1153,6 +1199,7 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
             {
                 if (is_d3d11_opaque(picture->format.i_chroma))
                     d3d11_device_unlock( &sys->d3d_dev );
+                msg_Dbg(vd, "Exit Prepare with error");
                 return;
             }
 
@@ -1306,11 +1353,14 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
 
     if (is_d3d11_opaque(picture->format.i_chroma))
         d3d11_device_unlock( &sys->d3d_dev );
+
+    msg_Dbg(vd, "Exit Prepare");
 }
 
 static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Display");
 
     DXGI_PRESENT_PARAMETERS presentParams;
     memset(&presentParams, 0, sizeof(presentParams));
@@ -1329,6 +1379,7 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
         subpicture_Delete(subpicture);
 
     CommonDisplay(vd);
+    msg_Dbg(vd, "Exit Display");
 }
 
 static void Direct3D11Destroy(vout_display_t *vd)
@@ -1683,7 +1734,7 @@ static void InitScaleProcessor(vout_display_t *vd)
 static int Direct3D11Open(vout_display_t *vd, bool external_device)
 {
     vout_display_sys_t *sys = vd->sys;
-    IDXGIFactory2 *dxgifactory;
+    msg_Dbg(vd, "Enter Direct3D11Open");
 
     char *psz_hdr = var_InheritString(vd, "d3d11-hdr-mode");
     sys->hdrMode = HdrModeFromString(VLC_OBJECT(vd), psz_hdr);
@@ -1701,12 +1752,14 @@ static int Direct3D11Open(vout_display_t *vd, bool external_device)
                                 &sys->d3d_dev);
         if (FAILED(hr)) {
         msg_Err(vd, "Could not Create the D3D11 device. (hr=0x%lX)", hr);
+        msg_Dbg(vd, "Exit Direct3D11Open with error");
         return VLC_EGENERIC;
         }
 
         IDXGIAdapter *dxgiadapter = D3D11DeviceAdapter(sys->d3d_dev.d3ddevice);
         if (unlikely(dxgiadapter==NULL)) {
         msg_Err(vd, "Could not get the DXGI Adapter");
+        msg_Dbg(vd, "Exit Direct3D11Open with error");
         return VLC_EGENERIC;
         }
 
@@ -1714,6 +1767,7 @@ static int Direct3D11Open(vout_display_t *vd, bool external_device)
         IDXGIAdapter_Release(dxgiadapter);
         if (FAILED(hr)) {
         msg_Err(vd, "Could not get the DXGI Factory. (hr=0x%lX)", hr);
+        msg_Dbg(vd, "Exit Direct3D11Open with error");
         return VLC_EGENERIC;
         }
 
@@ -1731,6 +1785,7 @@ static int Direct3D11Open(vout_display_t *vd, bool external_device)
         IDXGIFactory2_Release(dxgifactory);
         if (FAILED(hr)) {
         msg_Err(vd, "Could not create the SwapChain. (hr=0x%lX)", hr);
+        msg_Dbg(vd, "Exit Direct3D11Open with error");
         return VLC_EGENERIC;
         }
 #endif
@@ -1796,7 +1851,10 @@ static int Direct3D11Open(vout_display_t *vd, bool external_device)
             }
         }
         if (err != VLC_SUCCESS)
+        {
+            msg_Dbg(vd, "Exit Direct3D11Open with error");
             return err;
+        }
     }
 
     if (sys->upscaleMode == upscale_VideoProcessor || sys->upscaleMode == upscale_SuperResolution)
@@ -1811,6 +1869,7 @@ static int Direct3D11Open(vout_display_t *vd, bool external_device)
 
     if (Direct3D11CreateGenericResources(vd)) {
         msg_Err(vd, "Failed to allocate resources");
+        msg_Dbg(vd, "Exit Direct3D11Open with error");
         return VLC_EGENERIC;
     }
 
@@ -1819,6 +1878,7 @@ static int Direct3D11Open(vout_display_t *vd, bool external_device)
 
     sys->log_level = var_InheritInteger(vd, "verbose");
 
+    msg_Dbg(vd, "Exit Direct3D11Open");
     return VLC_SUCCESS;
 }
 
@@ -1906,6 +1966,7 @@ static const d3d_format_t *SelectOutputFormat(vout_display_t *vd, const video_fo
 static int SetupOutputFormat(vout_display_t *vd, video_format_t *fmt, video_format_t *quad_fmt)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter SetupOutputFormat");
 
     // look for the requested pixel format first
     const d3d_format_t *decoder_format = NULL;
@@ -1914,6 +1975,7 @@ static int SetupOutputFormat(vout_display_t *vd, video_format_t *fmt, video_form
     if ( !sys->picQuad.formatInfo )
     {
        msg_Err(vd, "Could not get a suitable texture pixel format");
+       msg_Dbg(vd, "Exit SetupOutputFormat with error");
        return VLC_EGENERIC;
     }
     sys->pool_d3dfmt = decoder_format ? decoder_format : sys->picQuad.formatInfo;
@@ -1948,16 +2010,19 @@ static int SetupOutputFormat(vout_display_t *vd, video_format_t *fmt, video_form
 
     if (Direct3D11CreateFormatResources(vd, quad_fmt)) {
         msg_Err(vd, "Failed to allocate format resources");
+        msg_Dbg(vd, "Exit SetupOutputFormat with error");
         return VLC_EGENERIC;
     }
     vd->info.is_slow = !is_d3d11_opaque(fmt->i_chroma) && sys->picQuad.formatInfo->formatTexture != DXGI_FORMAT_UNKNOWN;
 
+    msg_Dbg(vd, "Exit SetupOutputFormat");
     return VLC_SUCCESS;
 }
 
 static void Direct3D11Close(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Direct3D11Close");
 
     Direct3D11DestroyResources(vd);
     if (sys->dxgiswapChain4)
@@ -1974,11 +2039,13 @@ static void Direct3D11Close(vout_display_t *vd)
     D3D11_ReleaseDevice( &sys->d3d_dev );
 
     msg_Dbg(vd, "Direct3D11 device adapter closed");
+    msg_Dbg(vd, "Exit Direct3D11Close");
 }
 
 static void UpdatePicQuadPosition(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter UpdatePicQuadPosition");
 
     sys->picQuad.cropViewport.Width    = RECTWidth(sys->sys.rect_dest_clipped);
     sys->picQuad.cropViewport.Height   = RECTHeight(sys->sys.rect_dest_clipped);
@@ -1993,6 +2060,7 @@ static void UpdatePicQuadPosition(vout_display_t *vd)
 #ifndef NDEBUG
     msg_Dbg(vd, "picQuad position (%.02f,%.02f) %.02fx%.02f", sys->picQuad.cropViewport.TopLeftX, sys->picQuad.cropViewport.TopLeftY, sys->picQuad.cropViewport.Width, sys->picQuad.cropViewport.Height );
 #endif
+    msg_Dbg(vd, "Exit UpdatePicQuadPosition");
 }
 
 /* TODO : handle errors better
@@ -2000,6 +2068,7 @@ static void UpdatePicQuadPosition(vout_display_t *vd)
 static int Direct3D11CreateFormatResources(vout_display_t *vd, const video_format_t *fmt)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Direct3D11CreateFormatResources");
     HRESULT hr;
 
     hr = D3D11_CompilePixelShader(vd, &sys->hd3d, sys->legacy_shader, &sys->d3d_dev,
@@ -2009,6 +2078,7 @@ static int Direct3D11CreateFormatResources(vout_display_t *vd, const video_forma
     if (FAILED(hr))
     {
         msg_Err(vd, "Failed to create the pixel shader. (hr=0x%lX)", hr);
+        msg_Dbg(vd, "Exit Direct3D11CreateFormatResources with error");
         return VLC_EGENERIC;
     }
 
@@ -2023,10 +2093,14 @@ static int Direct3D11CreateFormatResources(vout_display_t *vd, const video_forma
         /* we need a staging texture */
         int ret = CreateStaging(vd, NULL);
         if (ret != VLC_SUCCESS)
+        {
+            msg_Dbg(vd, "Exit Direct3D11CreateFormatResources with error");
             return ret;
+        }
     }
 #endif
 
+    msg_Dbg(vd, "Exit Direct3D11CreateFormatResources");
     return VLC_SUCCESS;
 }
 
@@ -2071,6 +2145,7 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
     HRESULT hr;
+    msg_Dbg(vd, "Enter Direct3D11CreateGenericResources");
 
 #ifdef HAVE_D3D11_4_H
     hr = InitRenderFence(sys);
@@ -2106,6 +2181,7 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
     hr = ID3D11Device_CreateBlendState(sys->d3d_dev.d3ddevice, &spuBlendDesc, &pSpuBlendState);
     if (FAILED(hr)) {
        msg_Err(vd, "Could not create SPU blend state. (hr=0x%lX)", hr);
+       msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
        return VLC_EGENERIC;
     }
     ID3D11DeviceContext_OMSetBlendState(sys->d3d_dev.d3dcontext, pSpuBlendState, NULL, 0xFFFFFFFF);
@@ -2128,6 +2204,7 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
     hr = UpdateBackBuffer(vd);
     if (FAILED(hr)) {
        msg_Err(vd, "Could not update the backbuffer. (hr=0x%lX)", hr);
+       msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
        return VLC_EGENERIC;
     }
 
@@ -2145,13 +2222,17 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
                 sys->picQuad.d3dpixelShader = NULL;
             }
             msg_Err(vd, "Failed to create the SPU pixel shader. (hr=0x%lX)", hr);
+            msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
             return VLC_EGENERIC;
         }
     }
 
     ID3DBlob *pVSBlob = D3D11_CompileShader(vd, &sys->hd3d, &sys->d3d_dev, globVertexShaderFlat, false);
     if (!pVSBlob)
+    {
+        msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
         return VLC_EGENERIC;
+    }
 
     hr = ID3D11Device_CreateVertexShader(sys->d3d_dev.d3ddevice, (void *)ID3D10Blob_GetBufferPointer(pVSBlob),
                                         ID3D10Blob_GetBufferSize(pVSBlob), NULL, &sys->flatVSShader);
@@ -2159,6 +2240,7 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
     if(FAILED(hr)) {
       ID3D10Blob_Release(pVSBlob);
       msg_Err(vd, "Failed to create the flat vertex shader. (hr=0x%lX)", hr);
+      msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
       return VLC_EGENERIC;
     }
 
@@ -2174,12 +2256,16 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
 
     if(FAILED(hr)) {
       msg_Err(vd, "Failed to create the vertex input layout. (hr=0x%lX)", hr);
+      msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
       return VLC_EGENERIC;
     }
 
     pVSBlob = D3D11_CompileShader(vd, &sys->hd3d, &sys->d3d_dev, globVertexShaderProjection, false);
     if (!pVSBlob)
+    {
+        msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
         return VLC_EGENERIC;
+    }
 
     hr = ID3D11Device_CreateVertexShader(sys->d3d_dev.d3ddevice, (void *)ID3D10Blob_GetBufferPointer(pVSBlob),
                                         ID3D10Blob_GetBufferSize(pVSBlob), NULL, &sys->projectionVSShader);
@@ -2187,6 +2273,7 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
     if(FAILED(hr)) {
       ID3D10Blob_Release(pVSBlob);
       msg_Err(vd, "Failed to create the projection vertex shader. (hr=0x%lX)", hr);
+      msg_Dbg(vd, "Exit Direct3D11CreateGenericResources with error");
       return VLC_EGENERIC;
     }
     ID3D10Blob_Release(pVSBlob);
@@ -2196,6 +2283,7 @@ static int Direct3D11CreateGenericResources(vout_display_t *vd)
     UpdateSamplers(vd);
 
     msg_Dbg(vd, "Direct3D11 resources created");
+    msg_Dbg(vd, "Exit Direct3D11CreateGenericResources");
     return VLC_SUCCESS;
 }
 
@@ -2212,6 +2300,7 @@ static void Direct3D11DestroyPool(vout_display_t *vd)
 static void Direct3D11DestroyResources(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Direct3D11DestroyResources");
 
     Direct3D11DestroyPool(vd);
 
@@ -2283,6 +2372,7 @@ static void Direct3D11DestroyResources(vout_display_t *vd)
 #endif
 
     msg_Dbg(vd, "Direct3D11 resources destroyed");
+    msg_Dbg(vd, "Exit Direct3D11DestroyResources");
 }
 
 static void Direct3D11DeleteRegions(int count, picture_t **region)
@@ -2305,13 +2395,17 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
                                    picture_t ***region, subpicture_t *subpicture)
 {
     vout_display_sys_t *sys = vd->sys;
+    msg_Dbg(vd, "Enter Direct3D11MapSubpicture");
     D3D11_MAPPED_SUBRESOURCE mappedResource;
     D3D11_TEXTURE2D_DESC texDesc;
     HRESULT hr;
     int err;
 
     if (sys->d3dregion_format == NULL)
+    {
+        msg_Dbg(vd, "Exit Direct3D11MapSubpicture with error");
         return VLC_EGENERIC;
+    }
 
     int count = 0;
     for (subpicture_region_t *r = subpicture->p_region; r; r = r->p_next)
@@ -2319,7 +2413,10 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
     *region = calloc(count, sizeof(picture_t *));
     if (unlikely(*region==NULL))
+    {
+        msg_Dbg(vd, "Exit Direct3D11MapSubpicture with error");
         return VLC_ENOMEM;
+    }
     *subpicture_region_count = count;
 
     int i = 0;
@@ -2447,6 +2544,7 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
         D3D11_UpdateQuadOpacity(vd, &sys->d3d_dev, quad, r->i_alpha / 255.0f );
     }
+    msg_Dbg(vd, "Exit Direct3D11MapSubpicture");
     return VLC_SUCCESS;
 }
 
-- 
2.49.0.windows.1

